const path = require('path');
const fs = require('fs');

let sdkVersion = process.env.DOCS_VERSION || require('../package.json').version;
if (sdkVersion === 'unversioned') {
  // www API calls expect UNVERSIONED in all caps
  sdkVersion = 'UNVERSIONED';
} else {
  // Remove the leading 'v' for numeric versions
  sdkVersion = sdkVersion.includes('v') ? sdkVersion.substring(1) : sdkVersion;
}

// Stop now if outside of our monorepo
try {
  fs.statSync(`../server/www/xdl-schemas/${sdkVersion}-schema.json`);
  console.log('Schema file found, re-generating configuration docs');
} catch (e) {
  process.exit(0);
}

let ExpSchema;
try {
  ExpSchema = require(`../../server/www/xdl-schemas/${sdkVersion}-schema.json`)
    .schema;
} catch (e) {
  console.error(e.toString());
}

let rawPath;
let filePath;
if (!process.argv[2]) {
  let dirName = sdkVersion === 'UNVERSIONED' ? 'unversioned' : `v${sdkVersion}`;
  rawPath = `versions/${dirName}/guides/configuration.md`;
  filePath = path.resolve(rawPath);
  console.log('Using default target file path: ' + filePath.toString());
} else {
  rawPath = process.argv[2];
  filePath = path.resolve(rawPath);
}

const stream = fs.createWriteStream(filePath);

let preamble;
if (
  sdkVersion === 'UNVERSIONED' ||
  parseInt(sdkVersion.split('.')[0], 10) > 17
) {
  preamble = `
\`app.json\` is your go-to place for configuring parts of your app that don't belong in code. It is located at the root of your project next to your \`package.json\`. It looks something like this:

\`\`\`
{
  "expo": {
    "name": "My app",
    "slug": "my-app",
    "sdkVersion": "${sdkVersion}",
    "privacy": "public"
  }
}
\`\`\`

\`app.json\` was previous referred to as \`exp.json\`, but for consistency with [Create React Native App](https://github.com/react-community/create-react-native-app) it has been consolidated under one file. If you are converting your app from using \`exp.json\` to \`app.json\`, all you need to do is add an \`"expo"\` key at the root of \`app.json\`, as the parent of all other keys.

Most configuration from \`app.json\` is accessible at runtime from your JavaScript code via [\`Expo.Constants.manifest\`](../sdk/constants.html#expoconstantsmanifest). Sensitive information such as secret keys are removed. See the \`"extra"\` key below for information about how to pass arbitrary configuration data to your app.

The following is a list of properties that are available for you under the \`"expo"\` key in \`app.json\`:
\n
`;
} else {
  preamble = `
\`exp.json\` is your go-to place for configuring parts of your app that don't belong in code. It is located at the root of your project next to your \`package.json\`.  The following is a full list of properties available to you.\
\n
`;
}

// Open and write!
stream.once('open', function(fd) {
  const readableSchema = [];
  Object.keys(ExpSchema.properties).forEach(key => {
    if (shouldDisplayProperty(ExpSchema.properties[key])) {
      readableSchema.push(
        extractData(key, ExpSchema.properties[key], ExpSchema)
      );
    }
  });

  stream.write('---\n');
  if (
    sdkVersion === 'UNVERSIONED' ||
    parseInt(sdkVersion.split('.')[0], 10) > 17
  ) {
    stream.write('title: Configuration with app.json\n');
  } else {
    stream.write('title: Configuration with exp.json\n');
  }
  stream.write('---\n');

  stream.write(preamble);
  writePropertiesToStream(stream, readableSchema);
  stream.end();
});

function writePropertiesToStream(stream, schema, depth = 0) {
  schema.forEach(prop => {
    let depthSpacing = new Array(depth).join(' ');
    stream.write(`\n${depthSpacing}- \`${prop.key}\`\n`);
    stream.write(
      `\n${depthSpacing}   ${propertyDescription(prop, depthSpacing)}`
    );
    if (prop.children) {
      writePropertiesToStream(stream, prop.children, depth + 4);
    }
  });
}

/* Helper functions */

function propertyDescription(prop, depthSpacing) {
  let result = '';

  if (prop.isRequired) {
    result += '**Required**. ';
  }

  if (prop.isStandaloneOnly) {
    result += '**Standalone Apps Only**. ';
  }

  if (prop.description) {
    let lines = prop.description.split('\n');
    let description = lines
      .map((line, i) => {
        if (i === 0) {
          return `${line}\n`;
        } else {
          if (line.match(/^-/)) {
            return `${depthSpacing}   ${line}\n`;
          } else {
            return `${depthSpacing} ${line}\n`;
          }
        }
      })
      .join('');
    result += description;
  }

  if (prop.validOptions) {
    result += `${depthSpacing} ${prop.validOptions}\n`;
  }

  return result;
}

function shouldDisplayProperty(property) {
  if (property.meta && property.meta.autogenerated) {
    return false;
  }

  return true;
}

function extractValidOptions(property) {
  if (property.enum && property.enum.length) {
    return property.enum.join(', ');
  } else if (property.meta && property.meta.regexHuman) {
    return property.meta.regexHuman;
  }
}

function determineIfStandaloneOnly(property) {
  return property.meta && property.meta.standaloneOnly;
}

function extractData(key, property, parent) {
  let description = (property.description || '').trim();
  let type = property.type;
  let validOptions = extractValidOptions(property);
  let isRequired = parent.required && parent.required.includes(key);
  let isStandaloneOnly = determineIfStandaloneOnly(property);

  let data = {
    description,
    isRequired,
    isStandaloneOnly,
    key,
    type,
    validOptions,
  };

  let children = property.properties;
  if (children) {
    let mappedChildren = [];
    Object.keys(children).forEach(key => {
      if (shouldDisplayProperty(children[key])) {
        mappedChildren.push(extractData(key, children[key], property));
      }
    });
    data = Object.assign(data, { children: mappedChildren });
  }

  return data;
}
